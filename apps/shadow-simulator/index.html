<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-YV5WWWG39Z"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'G-YV5WWWG39Z');
  </script>
  <script>(function (w, d, s, l, i) {
      w[l] = w[l] || []; w[l].push({
        'gtm.start':
          new Date().getTime(), event: 'gtm.js'
      }); var f = d.getElementsByTagName(s)[0],
        j = d.createElement(s), dl = l != 'dataLayer' ? '&l=' + l : ''; j.async = true; j.src =
          'https://www.googletagmanager.com/gtm.js?id=' + i + dl; f.parentNode.insertBefore(j, f);
    })(window, document, 'script', 'dataLayer', 'GTM-PRPCBPS2');</script>

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>å½±ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ Pro (Lite UI) | æ¡œã‚¢ã‚«ãƒ‡ãƒŸã‚¢</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/DragControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/renderers/CSS2DRenderer.js"></script>

  <style>
    :root { --primary-navy: #1a2a44; --accent-yellow: #ffd600; --active-red: #ff5252; }
    * { box-sizing: border-box; touch-action: none; }
    body { margin: 0; overflow: hidden; background-color: #e3e6e8; font-family: "Helvetica Neue", Arial, sans-serif; color: #333; }
    
    #app-header { position: fixed; top: 0; left: 0; right: 0; height: 44px; background: var(--primary-navy); color: white; display: flex; align-items: center; justify-content: space-between; padding: 0 15px; z-index: 150; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
    .btn-home { color: white; text-decoration: none; font-size: 16px; font-weight: bold; display: flex; align-items: center; gap: 5px; }

    #controls {
      position: fixed; top: 44px; left: 0; width: 280px; bottom: 0;
      background: rgba(255,255,255,0.95); border-right: 1px solid #ddd;
      padding: 15px; overflow-y: auto; z-index: 100;
      display: flex; flex-direction: column; gap: 15px;
    }
    
    .ctrl-group { border-bottom: 1px solid #eee; padding-bottom: 12px; }
    .ctrl-group:last-child { border-bottom: none; }
    .ctrl-label { font-size: 12px; font-weight: bold; color: #555; margin-bottom: 6px; display: block; }
    
    /* ã‚«ãƒ¡ãƒ©ãƒœã‚¿ãƒ³ (2ã‚«ãƒ©ãƒ ã«å¤‰æ›´) */
    .cam-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 5px; }
    .btn-cam { 
      background: #fff; border: 1px solid #ccc; border-radius: 6px; padding: 8px 0; 
      cursor: pointer; font-size: 18px; text-align: center; transition: 0.2s;
      color: var(--primary-navy);
    }
    .btn-cam:hover { background: #eef2f5; border-color: var(--primary-navy); }
    .btn-cam span { font-size: 11px; display: block; color: #666; margin-top: 2px; font-weight: bold; }

    .row { display: flex; gap: 5px; align-items: center; }
    .btn-add { flex: 1; background: var(--primary-navy); color: white; border: none; padding: 8px; border-radius: 6px; font-weight: bold; cursor: pointer; display: flex; justify-content: center; align-items: center; gap: 5px; }
    .btn-add:hover { opacity: 0.9; }
    .btn-del { background: #fff; border: 1px solid var(--active-red); color: var(--active-red); padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: bold; }
    
    #obj-settings { background: #fff8e1; border: 1px solid #ffe082; padding: 10px; border-radius: 8px; display: none; }
    #obj-settings.active { display: block; animation: fadeIn 0.3s; }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

    .input-row { display: flex; align-items: center; gap: 5px; margin-bottom: 5px; }
    .input-row label { width: 30px; font-size: 11px; font-weight: bold; }
    input[type="number"] { width: 50px; padding: 4px; border: 1px solid #ccc; border-radius: 4px; text-align: center; font-weight: bold; }
    input[type="text"] { flex: 1; padding: 4px; border: 1px solid #ccc; border-radius: 4px; font-size: 13px; }
    input[type="range"] { flex: 1; cursor: pointer; }
    select { width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #ccc; font-size: 13px; }
    
    .toggle-row { display: flex; align-items: center; justify-content: space-between; background: #eef2f5; padding: 8px 12px; border-radius: 8px; cursor: pointer; margin-bottom: 5px;}
    .toggle-row span { font-size: 12px; font-weight: bold; }
    .toggle-check { width: 18px; height: 18px; accent-color: var(--primary-navy); cursor: pointer; }

    #area-panel {
      position: fixed; bottom: 20px; right: 20px; width: 240px;
      background: rgba(255, 255, 255, 0.95); border: 2px solid var(--primary-navy);
      border-radius: 12px; padding: 15px; box-shadow: 0 4px 15px rgba(0,0,0,0.15);
      z-index: 95; font-family: monospace; max-height: 40vh; overflow-y: auto;
    }
    .area-header { font-size: 12px; font-weight: bold; color: #666; border-bottom: 1px solid #ddd; padding-bottom: 5px; margin-bottom: 8px; }
    .area-list { list-style: none; padding: 0; margin: 0; }
    .area-item { display: flex; justify-content: space-between; margin-bottom: 6px; font-size: 13px; }
    .area-item.total { border-top: 1px dashed #ccc; padding-top: 6px; margin-top: 6px; font-weight: bold; color: var(--primary-navy); }
    .area-name { color: #444; }
    .area-val-wrap { text-align: right; }
    .area-val { font-weight: bold; color: var(--primary-navy); font-size: 15px; }
    .area-unit { font-size: 10px; color: #888; margin-left: 2px; }

    .label-tag {
      background: rgba(255, 255, 255, 0.85); border: 1px solid #999; border-radius: 4px;
      padding: 2px 6px; font-size: 12px; font-weight: bold; color: #333;
      pointer-events: none; user-select: none; box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    #guide-panel {
      position: fixed; top: 60px; right: 20px; width: 220px;
      background: rgba(26, 42, 68, 0.9); color: white;
      padding: 15px; border-radius: 10px; font-size: 12px; line-height: 1.5;
      box-shadow: 0 4px 10px rgba(0,0,0,0.2); pointer-events: none; z-index: 90;
    }
    .step { margin-bottom: 8px; display: flex; gap: 8px; }
    .step-icon { font-size: 16px; min-width: 20px; text-align: center; }

    @media (max-width: 768px) {
      #controls { top: auto; bottom: 0; left: 0; right: 0; width: 100%; height: 40vh; border-right: none; border-top: 1px solid #ddd; padding: 10px; gap: 10px; }
      #guide-panel { display: none; }
      #area-panel { top: 60px; bottom: auto; right: 10px; width: auto; min-width: 160px; padding: 10px; max-height: 30vh; }
    }
  </style>
</head>

<body>
  <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-PRPCBPS2" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>

  <header id="app-header">
    <a href="../index.html" class="btn-home">ğŸ  ãƒ›ãƒ¼ãƒ </a>
    <h1 style="font-size: 16px; margin: 0;">å½±ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ Pro</h1>
    <div style="width: 60px;"></div>
  </header>

  <aside id="controls">
    <div class="ctrl-group">
      <label class="ctrl-label">ã‚«ãƒ¡ãƒ©è¦–ç‚¹</label>
      <div class="cam-grid">
        <button class="btn-cam" onclick="setView('top')">â¬†ï¸<span>çœŸä¸Šã‹ã‚‰</span></button>
        <button class="btn-cam" onclick="setView('home')">ğŸ <span>æ–œã‚ã‹ã‚‰</span></button>
      </div>
    </div>

    <div class="ctrl-group">
      <label class="ctrl-label">æ–°ã—ã„ç‰©ä½“ã‚’è¿½åŠ </label>
      <div class="row" style="margin-bottom: 8px;">
        <select id="add-type">
          <option value="plate">ç›´ç«‹ã—ãŸæ¿ (åšã¿0)</option>
          <option value="cube">ç«‹æ–¹ä½“</option>
          <option value="box">ç›´æ–¹ä½“</option>
        </select>
      </div>
      <button class="btn-add" onclick="addNewObject()">
        <span>ï¼‹</span> è¿½åŠ ã™ã‚‹
      </button>
    </div>

    <div class="ctrl-group">
      <label class="toggle-row">
        <span>ğŸ§² ã‚°ãƒªãƒƒãƒ‰ã«å¸ç€ (1cm)</span>
        <input type="checkbox" id="snap-grid" class="toggle-check" checked>
      </label>
      <label class="toggle-row">
        <span>.00 å°æ•°ç‚¹ãƒ¢ãƒ¼ãƒ‰</span>
        <input type="checkbox" id="decimal-mode" class="toggle-check" onchange="toggleDecimalMode()">
      </label>
    </div>

    <div id="obj-settings" class="ctrl-group">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
        <label class="ctrl-label" style="color:#d32f2f; margin:0;">é¸æŠä¸­ã®ç‰©ä½“</label>
        <button class="btn-del" onclick="deleteSelected()">ğŸ—‘ï¸ å‰Šé™¤</button>
      </div>
      
      <div class="input-row">
        <label>åå‰</label>
        <input type="text" id="obj-name" onchange="updateName()">
      </div>

      <div class="input-row">
        <label>å¹…</label>
        <input type="number" id="size-w" min="1" max="20" step="1" onchange="updateSize()">
        <input type="range" id="range-w" min="1" max="20" step="1" oninput="syncSize('w')">
      </div>
      <div class="input-row">
        <label>é«˜</label>
        <input type="number" id="size-h" min="1" max="20" step="1" onchange="updateSize()">
        <input type="range" id="range-h" min="1" max="20" step="1" oninput="syncSize('h')">
      </div>
      <div class="input-row">
        <label>å¥¥</label>
        <input type="number" id="size-d" min="0" max="20" step="1" onchange="updateSize()">
        <input type="range" id="range-d" min="0" max="20" step="1" oninput="syncSize('d')">
      </div>
      <div class="input-row">
        <label>æµ®</label>
        <input type="number" id="pos-y" min="0" max="20" step="1" onchange="updatePos()">
        <input type="range" id="range-y" min="0" max="20" step="1" oninput="syncPos()">
      </div>
    </div>

    <div class="ctrl-group">
      <label class="ctrl-label">å…‰æºã®é«˜ã• (cm)</label>
      <div class="input-row">
        <input type="number" id="light-h" value="18" min="5" max="50" step="1" onchange="updateLight()">
        <input type="range" id="range-l" min="5" max="50" value="18" step="1" oninput="updateLight(true)">
      </div>
    </div>

    <div class="ctrl-group">
      <label class="toggle-row">
        <span>ğŸ“ è£œåŠ©ç·š (å…‰ã®é“)</span>
        <input type="checkbox" id="show-rays" class="toggle-check" checked onchange="updateAuxiliaryLines()">
      </label>
    </div>
  </aside>

  <div id="area-panel">
    <div class="area-header">å½±ã®é¢ç© (è¨ˆç®—çµæœ)</div>
    <ul class="area-list" id="area-list-content">
      <li class="area-item"><span class="area-name">åœ°é¢</span><div class="area-val-wrap"><span class="area-val">0.00</span><span class="area-unit">cmÂ²</span></div></li>
    </ul>
  </div>

  <div id="guide-panel">
    <h3>ğŸ”° ä½¿ã„æ–¹ã‚¬ã‚¤ãƒ‰</h3>
    <div class="step"><span class="step-icon">1</span><div><strong>è¦–ç‚¹ï¼š</strong>ã€Œâ¬†ï¸çœŸä¸Šã€ã§å¹³é¢å›³ã«ãªã‚Šã¾ã™ã€‚</div></div>
    <div class="step"><span class="step-icon">2</span><div><strong>è¿½åŠ ï¼š</strong>æ¿ã‚„ç®±ã‚’è¿½åŠ ã—ã¦ã€å£å½¹ã‚’ä½œã£ã¦ã¿ã¾ã—ã‚‡ã†ã€‚</div></div>
    <div class="step"><span class="step-icon">3</span><div><strong>é¢ç©ï¼š</strong>å³ä¸‹ã®ãƒ‘ãƒãƒ«ã«å½±ã®é¢ç©ãŒè‡ªå‹•è¨ˆç®—ã•ã‚Œã¾ã™ã€‚</div></div>
  </div>

  <canvas id="shadowCanvas" width="1024" height="1024" style="display:none;"></canvas>

  <script>
    let scene, camera, renderer, labelRenderer, controls, dragControls;
    let lightObj, pointLight, lightMarker, lightLine;
    let objects = [];
    let selectedObj = null;
    let rayLines = new THREE.Group();
    let boxHelper;
    let raycaster = new THREE.Raycaster();
    
    const defaultNames = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    let nameIndex = 0;

    const canvas = document.getElementById('shadowCanvas');
    const ctx = canvas.getContext('2d');
    const CANVAS_SCALE = 10; 
    const CANVAS_OFFSET = canvas.width / 2;

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xe3e6e8);
      
      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(30, 25, 30);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);

      labelRenderer = new THREE.CSS2DRenderer();
      labelRenderer.setSize(window.innerWidth, window.innerHeight);
      labelRenderer.domElement.style.position = 'absolute';
      labelRenderer.domElement.style.top = '0px';
      labelRenderer.domElement.style.pointerEvents = 'none';
      document.body.appendChild(labelRenderer.domElement);

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.target.set(0, 0, 0);

      const groundGeo = new THREE.PlaneGeometry(200, 200);
      const groundMat = new THREE.MeshPhongMaterial({ color: 0xe3e6e8 }); 
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true; 
      scene.add(ground);
      
      const grid = new THREE.GridHelper(100, 100, 0xb0b0b0, 0xd0d0d0);
      grid.position.y = 0.01;
      scene.add(grid);
      
      scene.add(new THREE.AmbientLight(0xffffff, 0.5));

      pointLight = new THREE.PointLight(0xffffff, 0.5, 200);
      pointLight.castShadow = true;
      pointLight.shadow.mapSize.width = 2048; 
      pointLight.shadow.mapSize.height = 2048;
      pointLight.shadow.bias = -0.0005;
      scene.add(pointLight);

      lightObj = new THREE.Mesh(new THREE.SphereGeometry(0.5), new THREE.MeshBasicMaterial({ color: 0xffff00 }));
      scene.add(lightObj);
      
      const axisSize = 100; 
      const axisGeo = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(-axisSize, 0.02, 0), new THREE.Vector3(axisSize, 0.02, 0),
        new THREE.Vector3(0, 0.02, -axisSize), new THREE.Vector3(0, 0.02, axisSize)
      ]);
      const axisMat = new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 2 });
      lightMarker = new THREE.LineSegments(axisGeo, axisMat);
      scene.add(lightMarker);

      const lineGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,10,0)]);
      lightLine = new THREE.Line(lineGeo, new THREE.LineDashedMaterial({ color: 0xff0000, dashSize: 0.5, gapSize: 0.3 }));
      lightLine.computeLineDistances();
      scene.add(lightLine);

      scene.add(rayLines);

      toggleDecimalMode();
      addNewObject('plate');
      updateLight();
      animate();
    }

    // --- è¦–ç‚¹å¤‰æ›´ ---
    window.setView = (view) => {
      controls.target.set(0, 0, 0);
      switch(view) {
        case 'top': camera.position.set(0, 50, 0); break;
        case 'home': camera.position.set(30, 25, 30); break;
      }
      controls.update();
    }

    // --- ç‰©ä½“æ“ä½œ (ä»¥ä¸‹ãƒ­ã‚¸ãƒƒã‚¯ç¶™ç¶š) ---
    function addNewObject(typeOverride) {
      const type = typeOverride || document.getElementById('add-type').value;
      let w=4, h=6, d=0, col=0xffffff;
      if(type === 'plate') { w=4; h=6; d=0.1; } 
      else if(type === 'cube') { w=4; h=4; d=4; } 
      else { w=4; h=8; d=4; } 

      const geo = new THREE.BoxGeometry(w, h, d);
      const mat = new THREE.MeshPhongMaterial({ color: col });
      const mesh = new THREE.Mesh(geo, mat);
      
      mesh.castShadow = true;
      mesh.receiveShadow = true;

      const edges = new THREE.EdgesGeometry(geo);
      const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.3 }));
      mesh.add(line);
      mesh.userData.edgeLine = line;

      const char = defaultNames[nameIndex % defaultNames.length];
      const suffix = Math.floor(nameIndex / defaultNames.length);
      mesh.name = "ç‰©ä½“" + char + (suffix > 0 ? suffix : "");
      nameIndex++;

      const div = document.createElement('div');
      div.className = 'label-tag';
      div.textContent = mesh.name;
      const label = new THREE.CSS2DObject(div);
      label.position.set(0, h/2 + 1, 0); 
      mesh.add(label);
      mesh.userData.label = label;

      const offset = Math.round((Math.random() - 0.5) * 6);
      let posX = 5 + offset;
      let posZ = 5 + offset;
      if (w % 2 !== 0) posX += 0.5;
      if (d % 2 !== 0 && d > 0.5) posZ += 0.5;

      mesh.position.set(posX, h/2, posZ);
      mesh.userData.groundY = 0;

      scene.add(mesh);
      objects.push(mesh);
      
      selectObject(mesh);
      setupDragControls();
      updateAuxiliaryLines();
      calculateAreas();
    }

    function setupDragControls() {
      if (dragControls) dragControls.dispose();
      dragControls = new THREE.DragControls(objects, camera, renderer.domElement);
      
      dragControls.addEventListener('dragstart', (e) => {
        controls.enabled = false;
        selectObject(e.object);
      });
      
      dragControls.addEventListener('drag', (e) => {
        const obj = e.object;
        const w = obj.geometry.parameters.width;
        const d = obj.geometry.parameters.depth;
        const h = obj.geometry.parameters.height;
        const isSnap = document.getElementById('snap-grid').checked;
        const isDecimal = document.getElementById('decimal-mode').checked;

        if (isSnap && !isDecimal) {
            const offX = (w % 2 !== 0) ? 0.5 : 0;
            const offZ = (d % 2 !== 0 && d >= 1) ? 0.5 : 0;
            obj.position.x = Math.round(obj.position.x - offX) + offX;
            obj.position.z = Math.round(obj.position.z - offZ) + offZ;
        } else if (isSnap) {
            obj.position.x = Math.round(obj.position.x);
            obj.position.z = Math.round(obj.position.z);
        }

        obj.position.y = obj.userData.groundY + (h / 2);
        updateAuxiliaryLines();
        calculateAreas(); 
      });
      
      dragControls.addEventListener('dragend', () => controls.enabled = true);
    }

    function selectObject(mesh) {
      selectedObj = mesh;
      if(boxHelper) scene.remove(boxHelper);
      boxHelper = new THREE.BoxHelper(mesh, 0xff5252);
      scene.add(boxHelper);
      document.getElementById('obj-settings').classList.add('active');
      document.getElementById('obj-name').value = mesh.name;
      
      const p = mesh.geometry.parameters;
      document.getElementById('size-w').value = p.width;
      document.getElementById('range-w').value = p.width;
      document.getElementById('size-h').value = p.height;
      document.getElementById('range-h').value = p.height;
      document.getElementById('size-d').value = p.depth;
      document.getElementById('range-d').value = p.depth;
      document.getElementById('pos-y').value = mesh.userData.groundY;
      document.getElementById('range-y').value = mesh.userData.groundY;
    }

    function updateName() {
      if(!selectedObj) return;
      const newName = document.getElementById('obj-name').value;
      selectedObj.name = newName;
      if(selectedObj.userData.label) {
        selectedObj.userData.label.element.textContent = newName;
      }
      calculateAreas();
    }

    function deleteSelected() {
      if(!selectedObj) return;
      scene.remove(selectedObj);
      if(boxHelper) scene.remove(boxHelper);
      objects = objects.filter(o => o !== selectedObj);
      selectedObj = null;
      document.getElementById('obj-settings').classList.remove('active');
      setupDragControls();
      updateAuxiliaryLines();
      calculateAreas();
    }

    window.syncSize = (axis) => { document.getElementById('size-' + axis).value = document.getElementById('range-' + axis).value; updateSize(); };
    window.syncPos = () => { document.getElementById('pos-y').value = document.getElementById('range-y').value; updatePos(); };

    function updateSize() {
      if(!selectedObj) return;
      const w = parseFloat(document.getElementById('size-w').value);
      const h = parseFloat(document.getElementById('size-h').value);
      const d = parseFloat(document.getElementById('size-d').value);
      
      if(selectedObj.userData.edgeLine) selectedObj.remove(selectedObj.userData.edgeLine);
      selectedObj.geometry.dispose();
      selectedObj.geometry = new THREE.BoxGeometry(w, h, d);
      
      const edges = new THREE.EdgesGeometry(selectedObj.geometry);
      const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.3 }));
      selectedObj.add(line);
      selectedObj.userData.edgeLine = line;

      if(selectedObj.userData.label) selectedObj.userData.label.position.set(0, h/2 + 1, 0);

      const isSnap = document.getElementById('snap-grid').checked;
      const isDecimal = document.getElementById('decimal-mode').checked;
      if(isSnap && !isDecimal) {
         const offX = (w % 2 !== 0) ? 0.5 : 0;
         const offZ = (d % 2 !== 0 && d >= 1) ? 0.5 : 0;
         selectedObj.position.x = Math.round(selectedObj.position.x - offX) + offX;
         selectedObj.position.z = Math.round(selectedObj.position.z - offZ) + offZ;
      }
      selectedObj.position.y = selectedObj.userData.groundY + (h / 2);
      if(boxHelper) boxHelper.update();
      updateAuxiliaryLines();
      calculateAreas();
    }

    function updatePos() {
      if(!selectedObj) return;
      const y = parseFloat(document.getElementById('pos-y').value);
      selectedObj.userData.groundY = y;
      const h = selectedObj.geometry.parameters.height;
      selectedObj.position.y = y + (h / 2);
      if(boxHelper) boxHelper.update();
      updateAuxiliaryLines();
      calculateAreas();
    }

    function updateLight(fromRange) {
      if(fromRange) document.getElementById('light-h').value = document.getElementById('range-l').value;
      else document.getElementById('range-l').value = document.getElementById('light-h').value;
      const h = parseFloat(document.getElementById('light-h').value);
      lightObj.position.set(0, h, 0);
      pointLight.position.set(0, h, 0);
      lightMarker.position.set(0, 0.01, 0);
      const positions = lightLine.geometry.attributes.position.array;
      positions[1] = 0; positions[4] = h;
      lightLine.geometry.attributes.position.needsUpdate = true;
      lightLine.computeLineDistances();
      updateAuxiliaryLines();
      calculateAreas();
    }

    function toggleDecimalMode() {
      const isDecimal = document.getElementById('decimal-mode').checked;
      const step = isDecimal ? "0.1" : "1";
      ['size-w', 'range-w', 'size-h', 'range-h', 'size-d', 'range-d', 'pos-y', 'range-y', 'light-h', 'range-l'].forEach(id => {
        const el = document.getElementById(id);
        if(el) el.setAttribute('step', step);
      });
      if(!isDecimal && selectedObj) {
        syncSize('w'); syncSize('h'); syncSize('d'); syncPos();
        updateLight();
      }
    }

    function updateAuxiliaryLines() {
      rayLines.clear();
      const showRays = document.getElementById('show-rays').checked;
      if (!showRays) return;
      const lightPos = lightObj.position;
      const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
      objects.forEach(obj => {
        obj.updateMatrixWorld(true);
        const posAttr = obj.geometry.getAttribute('position');
        const tempV = new THREE.Vector3();
        for (let i = 0; i < posAttr.count; i++) {
          tempV.fromBufferAttribute(posAttr, i);
          tempV.applyMatrix4(obj.matrixWorld);
          if (tempV.y < lightPos.y) {
            const dir = new THREE.Vector3().subVectors(tempV, lightPos).normalize();
            raycaster.set(lightPos, dir);
            const targets = objects.filter(o => o !== obj);
            const intersects = raycaster.intersectObjects(targets);
            let endPoint = null;
            if (intersects.length > 0) {
               const distToVertex = lightPos.distanceTo(tempV);
               const hit = intersects.find(h => h.distance > distToVertex + 0.01);
               if (hit) endPoint = hit.point;
            }
            if (!endPoint) {
               const target = new THREE.Vector3();
               const ray = new THREE.Ray(lightPos, dir);
               if (ray.intersectPlane(groundPlane, target)) endPoint = target;
            }
            if (endPoint) {
               const lineGeo = new THREE.BufferGeometry().setFromPoints([lightPos, endPoint]);
               const line = new THREE.Line(lineGeo, new THREE.LineDashedMaterial({ color: 0xff8800, dashSize: 0.5, gapSize: 0.5, opacity: 0.8, transparent: true, linewidth: 2 }));
               line.computeLineDistances();
               rayLines.add(line);
            }
          }
        }
      });
    }

    function getConvexHull(points) {
      points.sort((a, b) => a.x !== b.x ? a.x - b.x : a.z - b.z);
      const cross = (o, a, b) => (a.x - o.x) * (b.z - o.z) - (a.z - o.z) * (b.x - o.x);
      const lower = [];
      for (let p of points) {
        while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], p) <= 0) lower.pop();
        lower.push(p);
      }
      const upper = [];
      for (let i = points.length - 1; i >= 0; i--) {
        let p = points[i];
        while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], p) <= 0) upper.pop();
        upper.push(p);
      }
      lower.pop(); upper.pop();
      return lower.concat(upper);
    }

    function calculateAreas() {
      const listEl = document.getElementById('area-list-content');
      listEl.innerHTML = ''; 
      if (objects.length === 0) {
        listEl.innerHTML = '<li class="area-item"><span class="area-name">åœ°é¢</span><span class="area-val">0.00</span></li>';
        return;
      }
      const lightPos = lightObj.position;
      ctx.fillStyle = "white"; ctx.fillRect(0, 0, canvas.width, canvas.height); ctx.fillStyle = "black";
      objects.forEach(obj => {
        obj.updateMatrixWorld(true);
        const posAttr = obj.geometry.getAttribute('position');
        const vertices = [];
        for (let i = 0; i < posAttr.count; i++) {
          const v = new THREE.Vector3().fromBufferAttribute(posAttr, i);
          v.applyMatrix4(obj.matrixWorld);
          if (v.y < lightPos.y) {
            const t = lightPos.y / (lightPos.y - v.y);
            const sx = lightPos.x + t * (v.x - lightPos.x);
            const sz = lightPos.z + t * (v.z - lightPos.z);
            vertices.push({x: sx, z: sz});
          }
        }
        if (vertices.length >= 3) {
          const hull = getConvexHull(vertices);
          ctx.beginPath();
          hull.forEach((p, idx) => {
            const cx = p.x * CANVAS_SCALE + CANVAS_OFFSET;
            const cy = p.z * CANVAS_SCALE + CANVAS_OFFSET;
            if(idx===0) ctx.moveTo(cx, cy); else ctx.lineTo(cx, cy);
          });
          ctx.closePath(); ctx.fill();
        }
      });
      const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      let blackPixels = 0;
      for (let i = 0; i < imgData.data.length; i += 4) if (imgData.data[i] < 255) blackPixels++;
      const groundArea = blackPixels / (CANVAS_SCALE * CANVAS_SCALE);
      const groundLi = document.createElement('li');
      groundLi.className = 'area-item total';
      groundLi.innerHTML = `<span class="area-name">åœ°é¢</span><div class="area-val-wrap"><span class="area-val">${groundArea.toFixed(2)}</span><span class="area-unit">cmÂ²</span></div>`;
      listEl.appendChild(groundLi);

      const SAMPLE_DENSITY = 2; 
      objects.forEach(receiver => {
        let wallShadowCount = 0;
        const w = receiver.geometry.parameters.width;
        const h = receiver.geometry.parameters.height;
        const d = receiver.geometry.parameters.depth;
        const faces = [
          { u: w, v: h, pos: new THREE.Vector3(0, 0, d/2), norm: new THREE.Vector3(0,0,1), uDir: new THREE.Vector3(1,0,0), vDir: new THREE.Vector3(0,1,0) },
          { u: w, v: h, pos: new THREE.Vector3(0, 0, -d/2), norm: new THREE.Vector3(0,0,-1), uDir: new THREE.Vector3(-1,0,0), vDir: new THREE.Vector3(0,1,0) },
          { u: d, v: h, pos: new THREE.Vector3(-w/2, 0, 0), norm: new THREE.Vector3(-1,0,0), uDir: new THREE.Vector3(0,0,1), vDir: new THREE.Vector3(0,1,0) },
          { u: d, v: h, pos: new THREE.Vector3(w/2, 0, 0), norm: new THREE.Vector3(1,0,0), uDir: new THREE.Vector3(0,0,-1), vDir: new THREE.Vector3(0,1,0) },
          { u: w, v: d, pos: new THREE.Vector3(0, h/2, 0), norm: new THREE.Vector3(0,1,0), uDir: new THREE.Vector3(1,0,0), vDir: new THREE.Vector3(0,0,-1) },
          { u: w, v: d, pos: new THREE.Vector3(0, -h/2, 0), norm: new THREE.Vector3(0,-1,0), uDir: new THREE.Vector3(1,0,0), vDir: new THREE.Vector3(0,0,1) }
        ];
        faces.forEach(face => {
          if (face.u < 0.01 || face.v < 0.01) return;
          const faceCenter = face.pos.clone().applyMatrix4(receiver.matrixWorld);
          const faceNorm = face.norm.clone().transformDirection(receiver.matrixWorld);
          const dirToLight = new THREE.Vector3().subVectors(lightPos, faceCenter).normalize();
          if (faceNorm.dot(dirToLight) <= 0) return;
          const step = 1.0 / SAMPLE_DENSITY;
          for (let u = -face.u/2 + step/2; u < face.u/2; u += step) {
            for (let v = -face.v/2 + step/2; v < face.v/2; v += step) {
              const localPt = face.pos.clone().add(face.uDir.clone().multiplyScalar(u)).add(face.vDir.clone().multiplyScalar(v));
              const worldPt = localPt.applyMatrix4(receiver.matrixWorld);
              const dir = new THREE.Vector3().subVectors(lightPos, worldPt);
              const distToLight = dir.length();
              dir.normalize();
              raycaster.set(worldPt, dir);
              const obstacles = objects.filter(o => o !== receiver);
              const intersects = raycaster.intersectObjects(obstacles);
              if (intersects.length > 0) {
                if (intersects[0].distance < distToLight) wallShadowCount++;
              }
            }
          }
        });
        if (wallShadowCount > 0) {
          const area = wallShadowCount / (SAMPLE_DENSITY * SAMPLE_DENSITY);
          const li = document.createElement('li');
          li.className = 'area-item';
          li.innerHTML = `<span class="area-name">â†³ ${receiver.name}</span><div class="area-val-wrap"><span class="area-val">${area.toFixed(2)}</span><span class="area-unit">cmÂ²</span></div>`;
          listEl.insertBefore(li, listEl.firstChild);
        }
      });
    }

    function animate() { requestAnimationFrame(animate); controls.update(); if(boxHelper) boxHelper.update(); renderer.render(scene, camera); labelRenderer.render(scene, camera); }
    window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); labelRenderer.setSize(window.innerWidth, window.innerHeight); });
    init();
  </script>
</body>
</html>
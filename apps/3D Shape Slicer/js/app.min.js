let scene, camera, renderer, controls;
let planes = [], cutPoints = [], cutMarkers = [], capMeshes = [], currentCutIndex = 0;
const MAX_CUTS = 8;
let currentMesh, wireMesh, currentGeo, currentEdgesGeo;
let snapGroup = new THREE.Group();
let markerGroup = new THREE.Group();
let openDropdown = null;
let curDiv = 1;
let showWire = true;
let snapMode = 0; // 0:å…¨è¡¨ç¤º, 1:é¸æŠã®ã¿, 2:å…¨éè¡¨ç¤º

const CUT_COLORS = [0xff0000, 0x008000, 0x0000ff, 0xff8c00, 0x800080, 0x00ced1, 0xff00ff, 0x133b8b];

function toggleDropdown(id) {
    const panel = document.getElementById(id);
    if (openDropdown && openDropdown !== panel) openDropdown.classList.remove('open');
    panel.classList.toggle('open');
    openDropdown = panel.classList.contains('open') ? panel : null;
}
function closeAll() { if (openDropdown) { openDropdown.classList.remove('open'); openDropdown = null; } }

function setShapeUI(type) {
    document.querySelectorAll('#panel-shape .grid-btn').forEach(b => b.classList.remove('active'));
    setShape(type);
    document.getElementById('cube-params').classList.toggle('show', type === 'cube');
    document.getElementById('box-params').classList.toggle('show', type === 'box');
    if (type !== 'cube' && type !== 'box') closeAll();
}

function setDivisionUI(div) { curDiv = div; setDivision(div); closeAll(); }

function stepParam(id, delta, type) {
    const el = document.getElementById(id);
    let val = parseFloat(el.value) + delta;
    if (val < 1) val = 1;
    if (id === 'inp-cube-s') {
        if (val < 2) val = 2;
        if (val > 12) val = 12;
    }
    el.value = val;
    setShape(type);
}

function init() {
    scene = new THREE.Scene(); scene.background = new THREE.Color(0xfdfcf5);
    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(20, 20, 26);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.localClippingEnabled = true;
    document.body.appendChild(renderer.domElement);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    // è¡¨ç¤ºä½ç½®ã®ä¿®æ­£ï¼šåŸç‚¹(0,0,0)ã‚’ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«ã™ã‚‹
    controls.target.set(0, 0, 0);

    const ambientLight = new THREE.AmbientLight(0x808080); scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8); dirLight.position.set(10, 20, 10); scene.add(dirLight);

    for (let i = 0; i < MAX_CUTS; i++) {
        planes.push(new THREE.Plane(new THREE.Vector3(0, -1, 0), 10000));
        cutPoints.push([]); cutMarkers.push([]); capMeshes.push(null);
    }
    scene.add(snapGroup);
    scene.add(markerGroup);
    setShape('cube'); animate();
}

function setShape(type) {
    resetAllInternal();
    if (currentMesh) scene.remove(currentMesh, wireMesh);
    let geo, edgeGeo;
    if (type === 'cube') {
        const s = parseFloat(document.getElementById('inp-cube-s').value);
        geo = new THREE.BoxGeometry(s, s, s);
        edgeGeo = new THREE.EdgesGeometry(geo);
    } else if (type === 'box') {
        geo = new THREE.BoxGeometry(parseFloat(document.getElementById('inp-w').value), parseFloat(document.getElementById('inp-h').value), parseFloat(document.getElementById('inp-d').value));
        edgeGeo = new THREE.EdgesGeometry(geo);
    } else if (type === 'sphere') {
        geo = new THREE.SphereGeometry(6, 48, 48);
        edgeGeo = new THREE.EdgesGeometry(new THREE.SphereGeometry(6, 12, 10));
    } else if (type === 'prism-3') {
        geo = new THREE.CylinderGeometry(5, 5, 9, 3); edgeGeo = new THREE.EdgesGeometry(geo);
    } else if (type === 'prism-5') {
        geo = new THREE.CylinderGeometry(5, 5, 9, 5); edgeGeo = new THREE.EdgesGeometry(geo);
    } else if (type === 'prism-6') {
        geo = new THREE.CylinderGeometry(5, 5, 9, 6); edgeGeo = new THREE.EdgesGeometry(geo);
    } else if (type === 'cylinder') {
        geo = new THREE.CylinderGeometry(4, 4, 9, 32); edgeGeo = new THREE.EdgesGeometry(new THREE.CylinderGeometry(4, 4, 9, 12));
    } else if (type === 'pyramid-3') {
        geo = new THREE.ConeGeometry(6, 9, 3); edgeGeo = new THREE.EdgesGeometry(geo);
    } else if (type === 'pyramid-4') {
        geo = new THREE.ConeGeometry(6, 9, 4); edgeGeo = new THREE.EdgesGeometry(geo);
    } else if (type === 'pyramid-5') {
        geo = new THREE.ConeGeometry(6, 9, 5); edgeGeo = new THREE.EdgesGeometry(geo);
    } else if (type === 'pyramid-6') {
        geo = new THREE.ConeGeometry(6, 9, 6); edgeGeo = new THREE.EdgesGeometry(geo);
    } else if (type === 'cone') {
        geo = new THREE.ConeGeometry(6, 9, 32); edgeGeo = new THREE.EdgesGeometry(new THREE.ConeGeometry(6, 9, 12));
    } else if (type === 'poly-4') {
        geo = new THREE.TetrahedronGeometry(6); edgeGeo = new THREE.EdgesGeometry(geo);
    } else if (type === 'poly-8') {
        geo = new THREE.OctahedronGeometry(6); edgeGeo = new THREE.EdgesGeometry(geo);
    } else if (type === 'poly-12') {
        geo = new THREE.DodecahedronGeometry(6); edgeGeo = new THREE.EdgesGeometry(geo);
    } else if (type === 'poly-20') {
        geo = new THREE.IcosahedronGeometry(6); edgeGeo = new THREE.EdgesGeometry(geo);
    } else {
        geo = new THREE.BoxGeometry(6, 6, 6); edgeGeo = new THREE.EdgesGeometry(geo);
    }

    // è¡¨ç¤ºä½ç½®ã®ä¿®æ­£ï¼štranslate(3,0,0)ã‚’å‰Šé™¤ã—ã¦ä¸­å¤®é…ç½®
    currentGeo = geo; currentEdgesGeo = edgeGeo;
    currentMesh = new THREE.Mesh(geo, new THREE.MeshPhongMaterial({ color: 0xa8d5e2, side: THREE.DoubleSide, clippingPlanes: planes, clipShadows: true }));
    wireMesh = new THREE.LineSegments(edgeGeo, new THREE.LineBasicMaterial({ color: 0x000000, opacity: 0.3, transparent: true }));
    scene.add(currentMesh, wireMesh);
    wireMesh.visible = showWire; // ç¾åœ¨ã®è¡¨ç¤ºè¨­å®šã‚’é©ç”¨
    setDivision(curDiv);
}

const isTouchDevice = () => ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

function setDivision(div) {
    snapGroup.clear();
    const snapSize = isTouchDevice() ? 0.45 : 0.2;
    const dotMat = new THREE.MeshBasicMaterial({ color: 0x555555, opacity: 0.4, transparent: true });
    // ä¿®æ­£: ã‚¹ãƒŠãƒƒãƒ—ç‚¹ã®ç”Ÿæˆå…ƒã‚’ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ç”¨ãƒ¡ãƒƒã‚·ãƒ¥(é«˜è©³ç´°)ã‹ã‚‰ãƒ¯ã‚¤ãƒ¤ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ç”¨ãƒ¡ãƒƒã‚·ãƒ¥(ä½è©³ç´°)ã«å¤‰æ›´
    const posAttr = currentEdgesGeo ? currentEdgesGeo.attributes.position : currentMesh.geometry.attributes.position;
    const vertexSet = new Set();

    for (let i = 0; i < posAttr.count; i++) {
        const v = new THREE.Vector3().fromBufferAttribute(posAttr, i);
        // è§’æŸ±/å††æŸ±ã®ä¸­å¿ƒç‚¹ã‚’æ’é™¤ï¼ˆã‚»ãƒ³ã‚¿ãƒ¼åŒ–ã«ä¼´ã„åŸç‚¹åˆ¤å®šã«å¤‰æ›´ï¼‰
        const isPyramidApex = currentGeo.type === "ConeGeometry" && Math.abs(v.y - 4.5) < 0.01 && Math.abs(v.x - 0) < 0.01;
        const isOctahedron = currentGeo.type === 'OctahedronGeometry';
        const isSphere = currentGeo.type === 'SphereGeometry';
        // è§’æŸ±/å††æŸ±ã®ä¸­å¿ƒç‚¹ã‚’æ’é™¤ã€‚æ­£å…«é¢ä½“ã‚„çƒã®æ¥µç‚¹ã¯é™¤å¤–ã—ãªã„ã€‚
        const isCenterPoint = !isPyramidApex && !isOctahedron && !isSphere && Math.abs(v.x - 0) < 0.01 && Math.abs(v.z - 0) < 0.01;
        if (isCenterPoint) continue;

        const key = `${v.x.toFixed(3)},${v.y.toFixed(3)},${v.z.toFixed(3)}`;
        if (!vertexSet.has(key)) {
            const dot = new THREE.Mesh(new THREE.SphereGeometry(snapSize), dotMat);
            dot.position.copy(v); snapGroup.add(dot); vertexSet.add(key);
        }
    }

    if (div > 1 && currentEdgesGeo) {
        const attr = currentEdgesGeo.attributes.position;
        for (let i = 0; i < attr.count; i += 2) {
            const v1 = new THREE.Vector3().fromBufferAttribute(attr, i);
            const v2 = new THREE.Vector3().fromBufferAttribute(attr, i + 1);
            for (let j = 1; j < div; j++) {
                const dot = new THREE.Mesh(new THREE.SphereGeometry(snapSize), dotMat);
                dot.position.lerpVectors(v1, v2, j / div); snapGroup.add(dot);
            }
        }
    }
}

function calculateIntersectionPointsAndCreateCap(plane, idx) {
    const pts = []; const attr = currentEdgesGeo.attributes.position;
    for (let i = 0; i < attr.count; i += 2) {
        const v1 = new THREE.Vector3().fromBufferAttribute(attr, i), v2 = new THREE.Vector3().fromBufferAttribute(attr, i + 1);
        const line = new THREE.Line3(v1, v2); const target = new THREE.Vector3();
        if (plane.intersectLine(line, target)) if (!pts.some(p => p.distanceTo(target) < 0.01)) pts.push(target.clone());
    }
    if (capMeshes[idx]) scene.remove(capMeshes[idx]);
    if (pts.length >= 3) {
        const center = new THREE.Vector3(); pts.forEach(p => center.add(p)); center.divideScalar(pts.length);
        const normal = plane.normal.clone(); let ref = new THREE.Vector3(0, 1, 0); if (Math.abs(normal.dot(ref)) > 0.9) ref.set(1, 0, 0);
        const xDir = ref.cross(normal).normalize(), yDir = normal.clone().cross(xDir).normalize();
        pts.sort((a, b) => Math.atan2(a.clone().sub(center).dot(yDir), a.clone().sub(center).dot(xDir)) - Math.atan2(b.clone().sub(center).dot(yDir), b.clone().sub(center).dot(xDir)));
        const shape = new THREE.Shape(pts.map(p => new THREE.Vector2(p.clone().sub(center).dot(xDir), p.clone().sub(center).dot(yDir))));
        const cap = new THREE.Mesh(new THREE.ShapeGeometry(shape), new THREE.MeshPhongMaterial({
            color: CUT_COLORS[idx],
            side: THREE.DoubleSide,
            opacity: 0.6,
            transparent: true,
            clippingPlanes: planes.filter((_, i) => i !== idx),
            polygonOffset: true,
            polygonOffsetFactor: -1,
            polygonOffsetUnits: -1
        }));
        const m = new THREE.Matrix4().makeBasis(xDir, yDir, normal); cap.applyMatrix4(m); cap.position.copy(center);
        capMeshes[idx] = cap; scene.add(cap);
    }
}

const raycaster = new THREE.Raycaster(), mouse = new THREE.Vector2();
if (isTouchDevice()) { raycaster.params.Points.threshold = 1.5; }

window.addEventListener('pointerdown', (e) => {
    if (e.target.closest('#top-nav') || e.target.closest('#app-header')) return;
    mouse.x = (e.clientX / window.innerWidth) * 2 - 1; mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);

    // 1. æ—¢å­˜ãƒãƒ¼ã‚«ãƒ¼ã®ã‚¯ãƒªãƒƒã‚¯åˆ¤å®šï¼ˆè§£é™¤ç”¨ï¼‰
    const markerHits = raycaster.intersectObjects(markerGroup.children);
    if (markerHits.length > 0) {
        const hitMarker = markerHits[0].object;
        // ç¾åœ¨ã®ã‚¿ãƒ–ã®ãƒãƒ¼ã‚«ãƒ¼ã«å«ã¾ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
        const idx = cutMarkers[currentCutIndex].indexOf(hitMarker);
        if (idx !== -1) {
            // å‰Šé™¤å‡¦ç†
            markerGroup.remove(hitMarker);
            cutMarkers[currentCutIndex].splice(idx, 1);
            cutPoints[currentCutIndex].splice(idx, 1);

            // 3ç‚¹æƒã£ã¦ã„ãŸå ´åˆã¯åˆ‡æ–­ã‚’è§£é™¤ï¼ˆå¹³é¢ãƒªã‚»ãƒƒãƒˆï¼‰
            planes[currentCutIndex].setComponents(0, -1, 0, 10000);
            if (capMeshes[currentCutIndex]) {
                scene.remove(capMeshes[currentCutIndex]);
                capMeshes[currentCutIndex] = null;
            }

            updateUI();
            return; // æ–°è¦è¿½åŠ å‡¦ç†ã‚’è¡Œã‚ãªã„
        }
    }

    // 2. æ–°è¦ã‚¹ãƒŠãƒƒãƒ—ç‚¹ã®ã‚¯ãƒªãƒƒã‚¯åˆ¤å®š
    const hits = raycaster.intersectObjects(snapGroup.children);
    if (hits.length > 0) {
        const p = hits[0].object.position.clone(); if (cutPoints[currentCutIndex].length >= 3) return;
        cutPoints[currentCutIndex].push(p);
        const markerSize = isTouchDevice() ? 0.5 : 0.35;
        const m = new THREE.Mesh(new THREE.SphereGeometry(markerSize, 12, 10), new THREE.MeshBasicMaterial({ color: CUT_COLORS[currentCutIndex] }));
        m.position.copy(p); m.renderOrder = 999; markerGroup.add(m); cutMarkers[currentCutIndex].push(m);
        updateUI(); if (cutPoints[currentCutIndex].length === 3) applyCut();
    }
});

function applyCut() {
    const p = cutPoints[currentCutIndex];
    // åŒä¸€ç›´ç·šä¸Šãƒã‚§ãƒƒã‚¯: (p1-p0)ã¨(p2-p0)ã®å¤–ç©ãŒ0ã«è¿‘ã„å ´åˆã¯åŒä¸€ç›´ç·šä¸Š
    const v1 = new THREE.Vector3().subVectors(p[1], p[0]);
    const v2 = new THREE.Vector3().subVectors(p[2], p[0]);
    const cross = new THREE.Vector3().crossVectors(v1, v2);
    if (cross.length() < 0.0001) {
        resetCurrentCut();
        return;
    }
    planes[currentCutIndex].setFromCoplanarPoints(p[0], p[1], p[2]);
    calculateIntersectionPointsAndCreateCap(planes[currentCutIndex], currentCutIndex);
    updateUI();
}
function updateUI() {
    const len = cutPoints[currentCutIndex].length; document.getElementById('status-box').innerText = `${len} / 3`;
    document.getElementById('btn-flip').style.display = (len === 3) ? 'block' : 'none';
    document.getElementById('btn-reset-single').style.display = (len > 0) ? 'block' : 'none';
    for (let i = 0; i < MAX_CUTS; i++) { const t = document.getElementById('tab-' + i); if (t) { t.classList.toggle('active', i === currentCutIndex); t.classList.toggle('has-cut', cutPoints[i].length === 3); } }
}
window.switchCutTab = (idx) => { currentCutIndex = idx; updateUI(); };
window.flipCurrentCut = () => { planes[currentCutIndex].normal.negate(); planes[currentCutIndex].constant *= -1; calculateIntersectionPointsAndCreateCap(planes[currentCutIndex], currentCutIndex); };
window.resetCurrentCut = () => {
    cutPoints[currentCutIndex] = []; cutMarkers[currentCutIndex].forEach(m => markerGroup.remove(m)); cutMarkers[currentCutIndex] = [];
    planes[currentCutIndex].setComponents(0, -1, 0, 10000); if (capMeshes[currentCutIndex]) scene.remove(capMeshes[currentCutIndex]);
    capMeshes[currentCutIndex] = null; updateUI();
};

window.toggleWireframe = () => {
    showWire = !showWire;
    if (wireMesh) wireMesh.visible = showWire;
    const btn = document.getElementById('btn-toggle-wire');
    btn.innerText = showWire ? "ğŸ•¸ï¸ è£œåŠ©ç·šï¼šON" : "ğŸ•¸ï¸ è£œåŠ©ç·šï¼šOFF";
    btn.classList.toggle('active', showWire);
};

window.toggleSnapPoints = () => {
    snapMode = (snapMode + 1) % 3;
    const btn = document.getElementById('btn-toggle-snap');

    if (snapMode === 0) {
        // å…¨è¡¨ç¤º
        snapGroup.visible = true;
        markerGroup.visible = true;
        btn.innerText = "âš« ç‚¹ï¼šå…¨è¡¨ç¤º";
        btn.classList.add('active');
        btn.style.opacity = "1";
    } else if (snapMode === 1) {
        // é¸æŠã®ã¿
        snapGroup.visible = false;
        markerGroup.visible = true;
        btn.innerText = "âš« ç‚¹ï¼šé¸æŠã®ã¿";
        btn.classList.add('active');
        btn.style.opacity = "1"; // è‰²ãªã©ã§åŒºåˆ¥ã—ã¦ã‚‚è‰¯ã„ãŒä¸€æ—¦ãƒ†ã‚­ã‚¹ãƒˆã®ã¿å¤‰æ›´
    } else {
        // å…¨éè¡¨ç¤º
        snapGroup.visible = false;
        markerGroup.visible = false;
        btn.innerText = "âš« ç‚¹ï¼šå…¨éè¡¨ç¤º";
        btn.classList.remove('active');
        btn.style.opacity = "0.7";
    }
};

function resetAllInternal() { cutPoints.forEach((_, i) => { currentCutIndex = i; resetCurrentCut(); }); currentCutIndex = 0; updateUI(); }
window.resetAll = () => { resetAllInternal(); };
function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }
window.onload = () => {
    init();
};
window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });

let scene, camera, renderer, controls; let planes = [], cutPoints = [], cutMarkers = [], capMeshes = [], currentCutIndex = 0; const MAX_CUTS = 8; let currentMesh, wireMesh, currentGeo, currentEdgesGeo; let snapGroup = new THREE.Group(); let markerGroup = new THREE.Group(); let openDropdown = null; let curDiv = 1; let showWire = true; let snapMode = 0; const CUT_COLORS = [0xff0000, 0x008000, 0x0000ff, 0xff8c00, 0x800080, 0x00ced1, 0xff00ff, 0x133b8b]; function toggleDropdown(id) { const panel = document.getElementById(id); if (openDropdown && openDropdown !== panel) openDropdown.classList.remove('open'); panel.classList.toggle('open'); openDropdown = panel.classList.contains('open') ? panel : null } function closeAll() { if (openDropdown) { openDropdown.classList.remove('open'); openDropdown = null } } function setShapeUI(type) { document.querySelectorAll('#panel-shape .grid-btn').forEach(b => b.classList.remove('active')); setShape(type); document.getElementById('cube-params').classList.toggle('show', type === 'cube'); document.getElementById('box-params').classList.toggle('show', type === 'box'); if (type !== 'cube' && type !== 'box') closeAll() } function setDivisionUI(div) { curDiv = div; setDivision(div); closeAll() } function stepParam(id, delta, type) { const el = document.getElementById(id); let val = parseFloat(el.value) + delta; if (val < 1) val = 1; if (id === 'inp-cube-s') { if (val < 2) val = 2; if (val > 12) val = 12 } el.value = val; setShape(type) } function init() { scene = new THREE.Scene(); scene.background = new THREE.Color(0xfdfcf5); camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); camera.position.set(20, 20, 26); renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.localClippingEnabled = true; document.body.appendChild(renderer.domElement); controls = new THREE.OrbitControls(camera, renderer.domElement); controls.enableDamping = true; controls.target.set(0, 0, 0); const ambientLight = new THREE.AmbientLight(0x808080); scene.add(ambientLight); const dirLight = new THREE.DirectionalLight(0xffffff, 0.8); dirLight.position.set(10, 20, 10); scene.add(dirLight); for (let i = 0; i < MAX_CUTS; i++) { planes.push(new THREE.Plane(new THREE.Vector3(0, -1, 0), 10000)); cutPoints.push([]); cutMarkers.push([]); capMeshes.push(null) } scene.add(snapGroup); scene.add(markerGroup); setShape('cube'); animate() } function setShape(type) { resetAllInternal(); if (currentMesh) scene.remove(currentMesh, wireMesh); let geo, edgeGeo; if (type === 'cube') { const s = parseFloat(document.getElementById('inp-cube-s').value); geo = new THREE.BoxGeometry(s, s, s); edgeGeo = new THREE.EdgesGeometry(geo) } else if (type === 'box') { geo = new THREE.BoxGeometry(parseFloat(document.getElementById('inp-w').value), parseFloat(document.getElementById('inp-h').value), parseFloat(document.getElementById('inp-d').value)); edgeGeo = new THREE.EdgesGeometry(geo) } else if (type === 'sphere') { geo = new THREE.SphereGeometry(6, 48, 48); edgeGeo = new THREE.EdgesGeometry(new THREE.SphereGeometry(6, 12, 10)) } else if (type === 'prism-3') { geo = new THREE.CylinderGeometry(5, 5, 9, 3); edgeGeo = new THREE.EdgesGeometry(geo) } else if (type === 'prism-5') { geo = new THREE.CylinderGeometry(5, 5, 9, 5); edgeGeo = new THREE.EdgesGeometry(geo) } else if (type === 'prism-6') { geo = new THREE.CylinderGeometry(5, 5, 9, 6); edgeGeo = new THREE.EdgesGeometry(geo) } else if (type === 'cylinder') { geo = new THREE.CylinderGeometry(4, 4, 9, 32); edgeGeo = new THREE.EdgesGeometry(new THREE.CylinderGeometry(4, 4, 9, 12)) } else if (type === 'pyramid-3') { geo = new THREE.ConeGeometry(6, 9, 3); edgeGeo = new THREE.EdgesGeometry(geo) } else if (type === 'pyramid-4') { geo = new THREE.ConeGeometry(6, 9, 4); edgeGeo = new THREE.EdgesGeometry(geo) } else if (type === 'pyramid-5') { geo = new THREE.ConeGeometry(6, 9, 5); edgeGeo = new THREE.EdgesGeometry(geo) } else if (type === 'pyramid-6') { geo = new THREE.ConeGeometry(6, 9, 6); edgeGeo = new THREE.EdgesGeometry(geo) } else if (type === 'cone') { geo = new THREE.ConeGeometry(6, 9, 32); edgeGeo = new THREE.EdgesGeometry(new THREE.ConeGeometry(6, 9, 12)) } else if (type === 'poly-4') { geo = new THREE.TetrahedronGeometry(6); edgeGeo = new THREE.EdgesGeometry(geo) } else if (type === 'poly-8') { geo = new THREE.OctahedronGeometry(6); edgeGeo = new THREE.EdgesGeometry(geo) } else if (type === 'poly-12') { geo = new THREE.DodecahedronGeometry(6); edgeGeo = new THREE.EdgesGeometry(geo) } else if (type === 'poly-20') { geo = new THREE.IcosahedronGeometry(6); edgeGeo = new THREE.EdgesGeometry(geo) } else { geo = new THREE.BoxGeometry(6, 6, 6); edgeGeo = new THREE.EdgesGeometry(geo) } currentGeo = geo; currentEdgesGeo = edgeGeo; currentMesh = new THREE.Mesh(geo, new THREE.MeshPhongMaterial({ color: 0xa8d5e2, side: THREE.DoubleSide, clippingPlanes: planes, clipShadows: true })); wireMesh = new THREE.LineSegments(edgeGeo, new THREE.LineBasicMaterial({ color: 0x000000, opacity: 0.3, transparent: true })); scene.add(currentMesh, wireMesh); wireMesh.visible = showWire; setDivision(curDiv) } const isTouchDevice = () => ('ontouchstart' in window) || (navigator.maxTouchPoints > 0); function setDivision(div) { snapGroup.clear(); const snapSize = isTouchDevice() ? 0.45 : 0.2; const dotMat = new THREE.MeshBasicMaterial({ color: 0x555555, opacity: 0.4, transparent: true }); const posAttr = currentEdgesGeo ? currentEdgesGeo.attributes.position : currentMesh.geometry.attributes.position; const vertexSet = new Set(); for (let i = 0; i < posAttr.count; i++) { const v = new THREE.Vector3().fromBufferAttribute(posAttr, i); const isPyramidApex = currentGeo.type === "ConeGeometry" && Math.abs(v.y - 4.5) < 0.01 && Math.abs(v.x - 0) < 0.01; const isCenterPoint = !isPyramidApex && Math.abs(v.x - 0) < 0.01 && Math.abs(v.z - 0) < 0.01; if (isCenterPoint) continue; const key = `${v.x.toFixed(3)},${v.y.toFixed(3)},${v.z.toFixed(3)}`; if (!vertexSet.has(key)) { const dot = new THREE.Mesh(new THREE.SphereGeometry(snapSize), dotMat); dot.position.copy(v); snapGroup.add(dot); vertexSet.add(key) } } if (div > 1 && currentEdgesGeo) { const attr = currentEdgesGeo.attributes.position; for (let i = 0; i < attr.count; i += 2) { const v1 = new THREE.Vector3().fromBufferAttribute(attr, i); const v2 = new THREE.Vector3().fromBufferAttribute(attr, i + 1); for (let j = 1; j < div; j++) { const dot = new THREE.Mesh(new THREE.SphereGeometry(snapSize), dotMat); dot.position.lerpVectors(v1, v2, j / div); snapGroup.add(dot) } } } } function calculateIntersectionPointsAndCreateCap(plane, idx) { const pts = []; const attr = currentEdgesGeo.attributes.position; for (let i = 0; i < attr.count; i += 2) { const v1 = new THREE.Vector3().fromBufferAttribute(attr, i), v2 = new THREE.Vector3().fromBufferAttribute(attr, i + 1); const line = new THREE.Line3(v1, v2); const target = new THREE.Vector3(); if (plane.intersectLine(line, target)) if (!pts.some(p => p.distanceTo(target) < 0.01)) pts.push(target.clone()) } if (capMeshes[idx]) scene.remove(capMeshes[idx]); if (pts.length >= 3) { const center = new THREE.Vector3(); pts.forEach(p => center.add(p)); center.divideScalar(pts.length); const normal = plane.normal.clone(); let ref = new THREE.Vector3(0, 1, 0); if (Math.abs(normal.dot(ref)) > 0.9) ref.set(1, 0, 0); const xDir = ref.cross(normal).normalize(), yDir = normal.clone().cross(xDir).normalize(); pts.sort((a, b) => Math.atan2(a.clone().sub(center).dot(yDir), a.clone().sub(center).dot(xDir)) - Math.atan2(b.clone().sub(center).dot(yDir), b.clone().sub(center).dot(xDir))); const shape = new THREE.Shape(pts.map(p => new THREE.Vector2(p.clone().sub(center).dot(xDir), p.clone().sub(center).dot(yDir)))); const cap = new THREE.Mesh(new THREE.ShapeGeometry(shape), new THREE.MeshPhongMaterial({ color: CUT_COLORS[idx], side: THREE.DoubleSide, opacity: 0.6, transparent: true, clippingPlanes: planes.filter((_, i) => i !== idx) })); const m = new THREE.Matrix4().makeBasis(xDir, yDir, normal); cap.applyMatrix4(m); cap.position.copy(center); capMeshes[idx] = cap; scene.add(cap) } } const raycaster = new THREE.Raycaster(), mouse = new THREE.Vector2(); if (isTouchDevice()) { raycaster.params.Points.threshold = 1.5 } window.addEventListener('pointerdown', (e) => { if (e.target.closest('#top-nav') || e.target.closest('#app-header')) return; mouse.x = (e.clientX / window.innerWidth) * 2 - 1; mouse.y = -(e.clientY / window.innerHeight) * 2 + 1; raycaster.setFromCamera(mouse, camera); const markerHits = raycaster.intersectObjects(markerGroup.children); if (markerHits.length > 0) { const hitMarker = markerHits[0].object; const idx = cutMarkers[currentCutIndex].indexOf(hitMarker); if (idx !== -1) { markerGroup.remove(hitMarker); cutMarkers[currentCutIndex].splice(idx, 1); cutPoints[currentCutIndex].splice(idx, 1); planes[currentCutIndex].setComponents(0, -1, 0, 10000); if (capMeshes[currentCutIndex]) { scene.remove(capMeshes[currentCutIndex]); capMeshes[currentCutIndex] = null } updateUI(); return } } const hits = raycaster.intersectObjects(snapGroup.children); if (hits.length > 0) { const p = hits[0].object.position.clone(); if (cutPoints[currentCutIndex].length >= 3) return; cutPoints[currentCutIndex].push(p); const markerSize = isTouchDevice() ? 0.5 : 0.35; const m = new THREE.Mesh(new THREE.SphereGeometry(markerSize, 12, 10), new THREE.MeshBasicMaterial({ color: CUT_COLORS[currentCutIndex] })); m.position.copy(p); m.renderOrder = 999; markerGroup.add(m); cutMarkers[currentCutIndex].push(m); updateUI(); if (cutPoints[currentCutIndex].length === 3) applyCut() } }); function applyCut() { const p = cutPoints[currentCutIndex]; planes[currentCutIndex].setFromCoplanarPoints(p[0], p[1], p[2]); calculateIntersectionPointsAndCreateCap(planes[currentCutIndex], currentCutIndex); updateUI() } function updateUI() { const len = cutPoints[currentCutIndex].length; document.getElementById('status-box').innerText = `${len} / 3`; document.getElementById('btn-flip').style.display = (len === 3) ? 'block' : 'none'; document.getElementById('btn-reset-single').style.display = (len > 0) ? 'block' : 'none'; for (let i = 0; i < MAX_CUTS; i++) { const t = document.getElementById('tab-' + i); if (t) { t.classList.toggle('active', i === currentCutIndex); t.classList.toggle('has-cut', cutPoints[i].length === 3) } } } window.switchCutTab = (idx) => { currentCutIndex = idx; updateUI() }; window.flipCurrentCut = () => { planes[currentCutIndex].normal.negate(); planes[currentCutIndex].constant *= -1; calculateIntersectionPointsAndCreateCap(planes[currentCutIndex], currentCutIndex) }; window.resetCurrentCut = () => { cutPoints[currentCutIndex] = []; cutMarkers[currentCutIndex].forEach(m => markerGroup.remove(m)); cutMarkers[currentCutIndex] = []; planes[currentCutIndex].setComponents(0, -1, 0, 10000); if (capMeshes[currentCutIndex]) scene.remove(capMeshes[currentCutIndex]); capMeshes[currentCutIndex] = null; updateUI() }; window.toggleWireframe = () => { showWire = !showWire; if (wireMesh) wireMesh.visible = showWire; const btn = document.getElementById('btn-toggle-wire'); btn.innerText = showWire ? "ðŸ•¸ï¸ è£œåŠ©ç·šï¼šON" : "ðŸ•¸ï¸ è£œåŠ©ç·šï¼šOFF"; btn.classList.toggle('active', showWire) }; window.toggleSnapPoints = () => { snapMode = (snapMode + 1) % 3; const btn = document.getElementById('btn-toggle-snap'); if (snapMode === 0) { snapGroup.visible = true; markerGroup.visible = true; btn.innerText = "âš« ç‚¹ï¼šå…¨è¡¨ç¤º"; btn.classList.add('active'); btn.style.opacity = "1" } else if (snapMode === 1) { snapGroup.visible = false; markerGroup.visible = true; btn.innerText = "âš« ç‚¹ï¼šé¸æŠžã®ã¿"; btn.classList.add('active'); btn.style.opacity = "1" } else { snapGroup.visible = false; markerGroup.visible = false; btn.innerText = "âš« ç‚¹ï¼šå…¨éžè¡¨ç¤º"; btn.classList.remove('active'); btn.style.opacity = "0.7" } }; function resetAllInternal() { cutPoints.forEach((_, i) => { currentCutIndex = i; resetCurrentCut() }); currentCutIndex = 0; updateUI() } window.resetAll = () => { resetAllInternal() }; function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera) } window.onload = () => { init() }; window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight) });

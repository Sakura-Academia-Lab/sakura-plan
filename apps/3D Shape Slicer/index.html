<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ç«‹ä½“å›³å½¢ã‚¹ãƒ©ã‚¤ã‚µãƒ¼</title>
  <style>
    /* å…¨ä½“è¨­å®š */
    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      overflow: hidden;
      background-color: #fdfcf5;
      font-family: "Helvetica Neue", Arial, sans-serif;
    }

    /* ===== ä¸Šéƒ¨ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ ===== */
    #top-nav {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 100;
      background: rgba(255, 255, 255, 0.98);
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      padding: 8px 12px;
      gap: 8px;
    }

    /* ã‚¿ãƒ–ãƒœã‚¿ãƒ³å…±é€š */
    .nav-tab {
      position: relative;
      background: #f5f5f5;
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 8px 14px;
      font-size: 13px;
      font-weight: bold;
      color: #555;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 6px;
      transition: all 0.2s;
    }

    .nav-tab:hover {
      background: #e8e8e8;
    }

    .nav-tab.active {
      background: #a8d5e2;
      border-color: #81b3c3;
      color: #005662;
    }

    .nav-tab::after {
      content: 'â–¼';
      font-size: 10px;
      opacity: 0.6;
    }

    /* ãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³ãƒ‘ãƒãƒ« */
    .dropdown-panel {
      display: none;
      position: absolute;
      top: 100%;
      left: 0;
      margin-top: 4px;
      background: white;
      border: 1px solid #ddd;
      border-radius: 10px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
      padding: 12px;
      min-width: 280px;
      z-index: 200;
    }

    .dropdown-panel.open {
      display: block;
    }

    /* ã‚»ã‚¯ã‚·ãƒ§ãƒ³ */
    .section-title {
      font-size: 11px;
      font-weight: bold;
      color: #888;
      margin: 8px 0 6px 0;
      padding-bottom: 4px;
      border-bottom: 1px dashed #ddd;
    }

    .section-title:first-child {
      margin-top: 0;
    }

    /* å›³å½¢ãƒœã‚¿ãƒ³ã‚°ãƒªãƒƒãƒ‰ */
    .shape-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 6px;
      margin-bottom: 8px;
    }

    .shape-btn {
      padding: 8px 4px;
      font-size: 11px;
      cursor: pointer;
      border: 1px solid #ddd;
      border-radius: 6px;
      background: #fff;
      color: #666;
      text-align: center;
      transition: all 0.2s;
    }

    .shape-btn:hover {
      background: #f0f0f0;
    }

    .shape-btn.active {
      background: #a8d5e2;
      color: #005662;
      border-color: #81b3c3;
      font-weight: bold;
    }

    /* ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚¨ãƒªã‚¢ */
    .param-area {
      display: none;
      background: #e3f2fd;
      padding: 10px;
      border-radius: 8px;
      margin-top: 8px;
      border: 1px solid #bbdefb;
    }

    .param-area.show {
      display: block;
    }

    .param-row {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .param-item {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .param-label {
      font-size: 10px;
      color: #555;
      margin-bottom: 3px;
    }

    .param-item input {
      width: 100%;
      padding: 6px;
      text-align: center;
      border: 1px solid #ccc;
      border-radius: 6px;
      font-size: 13px;
    }

    /* ã‚¹ãƒŠãƒƒãƒ—ç‚¹ãƒœã‚¿ãƒ³ç¾¤ */
    .snap-buttons {
      display: flex;
      align-items: center;
      gap: 4px;
      flex-wrap: wrap;
    }

    .snap-label {
      font-size: 12px;
      font-weight: bold;
      color: #555;
      margin-right: 4px;
    }

    .snap-btn {
      background: #f5f5f5;
      border: 1px solid #ddd;
      border-radius: 6px;
      padding: 5px 10px;
      font-size: 11px;
      font-weight: bold;
      color: #666;
      cursor: pointer;
      transition: all 0.2s;
    }

    .snap-btn:hover {
      background: #e8e8e8;
    }

    .snap-btn.active {
      background: #81d4fa;
      border-color: #4fc3f7;
      color: #01579b;
    }

    /* ===== åˆ‡æ–­ãƒ‘ãƒãƒ« ===== */
    .cut-section {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-left: auto;
      flex-wrap: wrap;
    }

    .cut-tabs {
      display: flex;
      background: #eee;
      border-radius: 20px;
      padding: 3px;
      flex-wrap: wrap;
      max-width: 500px;
    }

    .cut-tab {
      background: transparent;
      border: none;
      padding: 4px 8px;
      border-radius: 14px;
      font-weight: bold;
      color: #888;
      cursor: pointer;
      font-size: 11px;
      transition: 0.2s;
    }

    .cut-tab.active {
      background: #fff;
      color: #ff9800;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    }

    .cut-tab.has-cut {
      color: #4CAF50;
    }

    .cut-tab.has-cut.active {
      color: #ff9800;
    }

    #status-box {
      font-size: 13px;
      font-weight: bold;
      color: #555;
      min-width: 50px;
      text-align: center;
    }

    .status-ok {
      color: #4CAF50 !important;
    }

    #btn-flip {
      background: #ffb74d;
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 12px;
      font-weight: bold;
      cursor: pointer;
      display: none;
      font-size: 12px;
    }

    #btn-flip:hover {
      background: #ffa726;
    }

    .reset-btns {
      display: flex;
      gap: 4px;
    }

    .btn-reset {
      font-size: 11px;
      padding: 5px 10px;
      border: 1px solid #ddd;
      background: #fff;
      color: #666;
      border-radius: 6px;
      cursor: pointer;
    }

    .btn-reset:hover {
      background: #fee;
      color: #d32f2f;
      border-color: #ef9a9a;
    }

    .btn-all-reset {
      font-size: 11px;
      padding: 5px 12px;
      background: #ef5350;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-weight: bold;
    }

    .btn-all-reset:hover {
      background: #e53935;
    }

    /* ã‚¬ã‚¤ãƒ‰ãƒ†ã‚­ã‚¹ãƒˆ */
    .guide-text {
      font-size: 11px;
      color: #888;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    /* ãƒ¢ãƒã‚¤ãƒ«å¯¾å¿œ */
    @media (max-width: 768px) {
      #top-nav {
        padding: 6px 8px;
        gap: 6px;
      }

      .nav-tab {
        padding: 6px 10px;
        font-size: 12px;
      }

      .cut-section {
        width: 100%;
        justify-content: center;
        margin-left: 0;
        margin-top: 4px;
      }

      .dropdown-panel {
        min-width: 260px;
        left: 50%;
        transform: translateX(-50%);
      }

      .guide-text {
        display: none;
      }
    }

    /* å¯¸æ³•ãƒ©ãƒ™ãƒ« */
    .dim-toggle {
      display: flex;
      align-items: center;
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px dashed #abc;
      cursor: pointer;
      font-size: 12px;
      font-weight: bold;
      color: #005662;
    }

    .dim-toggle input {
      margin-right: 6px;
      cursor: pointer;
    }
  </style>

  <script src="libs/three.min.js"></script>
  <script src="libs/OrbitControls.js"></script>
</head>

<body>

  <!-- ä¸Šéƒ¨ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ -->
  <nav id="top-nav">
    <!-- å›³å½¢é¸æŠã‚¿ãƒ– -->
    <div class="nav-tab" id="shape-tab" onclick="toggleDropdown('shape-dropdown')">
      ğŸ“ å›³å½¢é¸æŠ
    </div>
    <div class="dropdown-panel" id="shape-dropdown">
      <div class="section-title">åŸºæœ¬å›³å½¢</div>
      <div class="shape-grid">
        <button class="shape-btn active" id="btn-cube" onclick="setShapeUI('cube')">ç«‹æ–¹ä½“</button>
        <button class="shape-btn" id="btn-box" onclick="setShapeUI('box')">ç›´æ–¹ä½“</button>
        <button class="shape-btn" id="btn-sphere" onclick="setShapeUI('sphere')">çƒ</button>
      </div>

      <div class="section-title">æŸ±ä½“</div>
      <div class="shape-grid">
        <button class="shape-btn" id="btn-prism-3" onclick="setShapeUI('prism-3')">ä¸‰è§’æŸ±</button>
        <button class="shape-btn" id="btn-prism-5" onclick="setShapeUI('prism-5')">äº”è§’æŸ±</button>
        <button class="shape-btn" id="btn-prism-6" onclick="setShapeUI('prism-6')">å…­è§’æŸ±</button>
        <button class="shape-btn" id="btn-cylinder" onclick="setShapeUI('cylinder')">å††æŸ±</button>
      </div>

      <div class="section-title">éŒä½“</div>
      <div class="shape-grid">
        <button class="shape-btn" id="btn-pyramid-3" onclick="setShapeUI('pyramid-3')">ä¸‰è§’éŒ</button>
        <button class="shape-btn" id="btn-pyramid-4" onclick="setShapeUI('pyramid-4')">å››è§’éŒ</button>
        <button class="shape-btn" id="btn-pyramid-5" onclick="setShapeUI('pyramid-5')">äº”è§’éŒ</button>
        <button class="shape-btn" id="btn-pyramid-6" onclick="setShapeUI('pyramid-6')">å…­è§’éŒ</button>
        <button class="shape-btn" id="btn-cone" onclick="setShapeUI('cone')">å††éŒ</button>
      </div>

      <div class="section-title">æ­£å¤šé¢ä½“</div>
      <div class="shape-grid">
        <button class="shape-btn" id="btn-poly-4" onclick="setShapeUI('poly-4')">æ­£å››é¢ä½“</button>
        <button class="shape-btn" id="btn-poly-8" onclick="setShapeUI('poly-8')">æ­£å…«é¢ä½“</button>
        <button class="shape-btn" id="btn-poly-12" onclick="setShapeUI('poly-12')">æ­£åäºŒé¢ä½“</button>
        <button class="shape-btn" id="btn-poly-20" onclick="setShapeUI('poly-20')">æ­£äºŒåé¢ä½“</button>
      </div>

      <!-- ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚¨ãƒªã‚¢ -->
      <div id="cube-param-area" class="param-area">
        <div class="param-row">
          <div class="param-item">
            <span class="param-label">ä¸€è¾ºã®é•·ã•</span>
            <input type="number" id="inp-cube-s" value="7" min="2" max="12" onchange="updateCubeParams()">
          </div>
        </div>
      </div>

      <div id="box-param-area" class="param-area">
        <div class="param-row">
          <div class="param-item">
            <span class="param-label">æ¨ª(W)</span>
            <input type="number" id="inp-w" value="5" min="2" max="12" onchange="updateBoxParams()">
          </div>
          <div class="param-item">
            <span class="param-label">é«˜ã•(H)</span>
            <input type="number" id="inp-h" value="8" min="2" max="12" onchange="updateBoxParams()">
          </div>
          <div class="param-item">
            <span class="param-label">å¥¥è¡Œ(D)</span>
            <input type="number" id="inp-d" value="5" min="2" max="12" onchange="updateBoxParams()">
          </div>
        </div>
        <label class="dim-toggle">
          <input type="checkbox" id="chk-dim" checked onchange="toggleDimensions()">
          ğŸ“ å¯¸æ³•ç·šã‚’è¡¨ç¤º
        </label>
      </div>
    </div>

    <!-- ã‚¹ãƒŠãƒƒãƒ—ç‚¹ãƒœã‚¿ãƒ³ç¾¤ -->
    <div class="snap-buttons">
      <span class="snap-label">ğŸ“ ç­‰åˆ†ç‚¹:</span>
      <button class="snap-btn active" data-div="1" onclick="setDivision(1)">é ‚ç‚¹ã®ã¿</button>
      <button class="snap-btn" data-div="2" onclick="setDivision(2)">2ç­‰åˆ†</button>
      <button class="snap-btn" data-div="3" onclick="setDivision(3)">3ç­‰åˆ†</button>
      <button class="snap-btn" data-div="4" onclick="setDivision(4)">4ç­‰åˆ†</button>
      <button class="snap-btn" data-div="5" onclick="setDivision(5)">5ç­‰åˆ†</button>
      <button class="snap-btn" data-div="6" onclick="setDivision(6)">6ç­‰åˆ†</button>
      <button class="snap-btn" data-div="8" onclick="setDivision(8)">8ç­‰åˆ†</button>
      <button class="snap-btn" data-div="10" onclick="setDivision(10)">10ç­‰åˆ†</button>
    </div>

    <!-- åˆ‡æ–­ã‚»ã‚¯ã‚·ãƒ§ãƒ³ -->
    <div class="cut-section">
      <span class="guide-text">ğŸ‘† 3ç‚¹ã‚¯ãƒªãƒƒã‚¯ã§åˆ‡æ–­</span>
      <div class="cut-tabs" id="cut-tabs-container">
        <button class="cut-tab active" id="cut-tab-0" onclick="switchCutTab(0)">åˆ‡æ–­â‘ </button>
        <button class="cut-tab" id="cut-tab-1" onclick="switchCutTab(1)">åˆ‡æ–­â‘¡</button>
        <button class="cut-tab" id="cut-tab-2" onclick="switchCutTab(2)">åˆ‡æ–­â‘¢</button>
        <button class="cut-tab" id="cut-tab-3" onclick="switchCutTab(3)">åˆ‡æ–­â‘£</button>
        <button class="cut-tab" id="cut-tab-4" onclick="switchCutTab(4)">åˆ‡æ–­â‘¤</button>
        <button class="cut-tab" id="cut-tab-5" onclick="switchCutTab(5)">åˆ‡æ–­â‘¥</button>
        <button class="cut-tab" id="cut-tab-6" onclick="switchCutTab(6)">åˆ‡æ–­â‘¦</button>
        <button class="cut-tab" id="cut-tab-7" onclick="switchCutTab(7)">åˆ‡æ–­â‘§</button>
        <button class="cut-tab" id="cut-tab-8" onclick="switchCutTab(8)">åˆ‡æ–­â‘¨</button>
        <button class="cut-tab" id="cut-tab-9" onclick="switchCutTab(9)">åˆ‡æ–­â‘©</button>
      </div>
      <span id="status-box">0 / 3</span>
      <button id="btn-flip" onclick="flipCurrentCut()">ğŸ” é€†å´</button>
      <div class="reset-btns">
        <button class="btn-reset" onclick="resetCurrentCut()">ã“ã®åˆ‡æ–­ã‚’æ¶ˆå»</button>
        <button class="btn-all-reset" onclick="resetAll()">ğŸ—‘ å…¨ãƒªã‚»ãƒƒãƒˆ</button>
      </div>
    </div>
  </nav>

  <script>
    // ===== ãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³åˆ¶å¾¡ =====
    let openDropdown = null;

    function toggleDropdown(id) {
      const panel = document.getElementById(id);
      if (openDropdown && openDropdown !== panel) {
        openDropdown.classList.remove('open');
      }
      panel.classList.toggle('open');
      openDropdown = panel.classList.contains('open') ? panel : null;
    }

    // å¤–éƒ¨ã‚¯ãƒªãƒƒã‚¯ã§é–‰ã˜ã‚‹
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.nav-tab') && !e.target.closest('.dropdown-panel')) {
        if (openDropdown) {
          openDropdown.classList.remove('open');
          openDropdown = null;
        }
      }
    });

    // ===== Three.js ã‚·ãƒ¼ãƒ³è¨­å®š =====
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xfdfcf5);
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(20, 20, 26);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.localClippingEnabled = true;
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.target.set(3, 0, 0);

    const ambientLight = new THREE.AmbientLight(0x808080); scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.7); dirLight.position.set(10, 20, 10); dirLight.castShadow = true; scene.add(dirLight);
    const fillLight = new THREE.DirectionalLight(0xffffff, 0.4); fillLight.position.set(-10, 5, -10); scene.add(fillLight);

    // ===== åˆ‡æ–­ãƒ—ãƒ¬ãƒ¼ãƒ³ï¼ˆå‹•çš„é…åˆ—ï¼‰ =====
    const MAX_CUTS = 10;
    let planes = [];
    let cutPoints = [];
    let cutMarkers = [];
    let capMeshes = [];
    let currentCutIndex = 0;
    let numCuts = 10; // åˆæœŸã¯10å€‹ï¼ˆæœ€å¤§ï¼‰

    function initCuts(count) {
      planes = [];
      cutPoints = [];
      cutMarkers = [];
      capMeshes = [];
      for (let i = 0; i < count; i++) {
        planes.push(new THREE.Plane(new THREE.Vector3(0, -1, 0), 1000));
        cutPoints.push([]);
        cutMarkers.push([]);
        capMeshes.push(null);
      }
    }
    initCuts(numCuts);

    const SHAPE_COLOR = 0xa8d5e2;
    const SECTION_COLOR = 0x5d99c6;

    let currentMesh = null;
    let wireframeMesh = null;
    let currentGeometry = null;
    let currentEdgesGeometry = null;
    let snapPointsGroup = new THREE.Group();
    let intersectSnapGroup = new THREE.Group();
    scene.add(snapPointsGroup, intersectSnapGroup);

    const matSolid = new THREE.MeshPhongMaterial({
      color: SHAPE_COLOR, specular: 0x111111, shininess: 30,
      side: THREE.DoubleSide,
      clippingPlanes: planes,
      clipShadows: true
    });
    const wireMat = new THREE.LineBasicMaterial({ color: 0x000000, opacity: 0.8, transparent: true });

    // ===== å¯¸æ³•ç·šæ©Ÿèƒ½ =====
    function addDimensions(mesh) {
      if (mesh.userData.dimensionGroup) {
        mesh.remove(mesh.userData.dimensionGroup);
        mesh.userData.dimensionGroup = null;
      }
      const isShow = document.getElementById('chk-dim').checked;
      if (!isShow) return;
      if (!mesh.geometry.parameters) return;

      const { width, height, depth } = mesh.geometry.parameters;
      const group = new THREE.Group();

      function createLabel(text, color, position) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 256; canvas.height = 128;
        ctx.fillStyle = color; ctx.font = 'bold 50px Arial';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(text, canvas.width / 2, canvas.height / 2);
        const texture = new THREE.CanvasTexture(canvas);
        const mat = new THREE.SpriteMaterial({ map: texture, transparent: true, depthTest: false });
        const sp = new THREE.Sprite(mat);
        sp.scale.set(4, 2, 1); sp.position.copy(position); sp.renderOrder = 999;
        return sp;
      }

      const cx = 3;
      const labelX = createLabel(`æ¨ª: ${width}`, '#ff4444', new THREE.Vector3(cx, -height / 2 - 1.2, 0)); group.add(labelX);
      const labelY = createLabel(`é«˜ã•: ${height}`, '#44aa44', new THREE.Vector3(cx - width / 2 - 1.2, 0, 0)); group.add(labelY);
      const labelZ = createLabel(`å¥¥è¡Œ: ${depth}`, '#4444ff', new THREE.Vector3(cx + width / 2 + 1.2, -height / 2, depth / 2)); group.add(labelZ);
      mesh.add(group);
      mesh.userData.dimensionGroup = group;
    }

    window.toggleDimensions = function () {
      if (currentMesh && currentMesh.userData.type === 'box') {
        addDimensions(currentMesh);
      }
    }

    // ===== UIç®¡ç† =====
    let currentShapeType = 'cube';

    window.setShapeUI = function (type) {
      currentShapeType = type;
      // å…¨ãƒœã‚¿ãƒ³ã®activeã‚’è§£é™¤
      document.querySelectorAll('.shape-btn').forEach(b => b.classList.remove('active'));
      const btn = document.getElementById('btn-' + type);
      if (btn) btn.classList.add('active');

      // ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚¨ãƒªã‚¢è¡¨ç¤ºåˆ¶å¾¡
      document.getElementById('cube-param-area').classList.toggle('show', type === 'cube');
      document.getElementById('box-param-area').classList.toggle('show', type === 'box');

      setShape(type);
    }

    window.updateCubeParams = function () { setShape('cube'); }
    window.updateBoxParams = function () { setShape('box'); }

    // ===== å›³å½¢ç”Ÿæˆ =====
    function setShape(type) {
      if (currentMesh) {
        scene.remove(currentMesh); scene.remove(wireframeMesh);
        capMeshes.forEach(c => { if (c) scene.remove(c); });
        for (let i = 0; i < capMeshes.length; i++) capMeshes[i] = null;
      }
      currentDivision = 1;
      document.querySelectorAll('.snap-btn').forEach(btn => {
        btn.classList.toggle('active', parseInt(btn.dataset.div) === 1);
      });

      let geometry;
      let isSphere = false;

      if (type === 'cube') {
        const s = parseFloat(document.getElementById('inp-cube-s').value) || 7;
        geometry = new THREE.BoxGeometry(s, s, s);
      } else if (type === 'box') {
        const w = parseFloat(document.getElementById('inp-w').value) || 5;
        const h = parseFloat(document.getElementById('inp-h').value) || 8;
        const d = parseFloat(document.getElementById('inp-d').value) || 5;
        geometry = new THREE.BoxGeometry(w, h, d);
      }
      else if (type === 'sphere') {
        isSphere = true;
        geometry = new THREE.SphereGeometry(6, 64, 64);
      }
      else if (type.startsWith('prism-')) {
        const n = parseInt(type.split('-')[1]);
        geometry = new THREE.CylinderGeometry(5, 5, 9, n);
      } else if (type === 'cylinder') {
        geometry = new THREE.CylinderGeometry(4, 4, 9, 32);
      }
      else if (type.startsWith('pyramid-')) {
        const n = parseInt(type.split('-')[1]);
        geometry = new THREE.ConeGeometry(6, 9, n);
      } else if (type === 'cone') {
        geometry = new THREE.ConeGeometry(5, 9, 32);
      }
      else if (type === 'poly-4') { geometry = new THREE.TetrahedronGeometry(6); }
      else if (type === 'poly-8') { geometry = new THREE.OctahedronGeometry(5); }
      else if (type === 'poly-12') { geometry = new THREE.DodecahedronGeometry(5); }
      else if (type === 'poly-20') { geometry = new THREE.IcosahedronGeometry(5); }

      currentGeometry = geometry;
      geometry.translate(3, 0, 0);

      let edgesGeometry;
      if (isSphere) {
        const lowPolySphere = new THREE.SphereGeometry(6, 16, 12);
        lowPolySphere.translate(3, 0, 0);
        edgesGeometry = new THREE.WireframeGeometry(lowPolySphere);
      } else if (type === 'cylinder' || type === 'cone') {
        edgesGeometry = new THREE.EdgesGeometry(geometry, 20);
      } else {
        edgesGeometry = new THREE.EdgesGeometry(geometry);
      }

      // ãƒãƒ†ãƒªã‚¢ãƒ«ã®clipping planesã‚’æ›´æ–°
      matSolid.clippingPlanes = planes;

      currentMesh = new THREE.Mesh(geometry, matSolid);
      currentMesh.userData = { type: type };
      currentMesh.renderOrder = 0;
      scene.add(currentMesh);

      if (type === 'box') addDimensions(currentMesh);

      currentEdgesGeometry = edgesGeometry;
      wireframeMesh = new THREE.LineSegments(currentEdgesGeometry, wireMat);

      if (isSphere) {
        wireframeMesh.material = new THREE.LineBasicMaterial({ color: 0x000000, opacity: 0.2, transparent: true });
      }

      scene.add(wireframeMesh);
      resetAll();
    }

    // ===== ã‚¹ãƒŠãƒƒãƒ—ãƒ»åˆ‡æ–­å‡¦ç† =====
    let currentDivision = 1;

    window.setDivision = function (div) {
      currentDivision = div;
      // ãƒœã‚¿ãƒ³ã®activeçŠ¶æ…‹ã‚’æ›´æ–°
      document.querySelectorAll('.snap-btn').forEach(btn => {
        btn.classList.toggle('active', parseInt(btn.dataset.div) === div);
      });
      createSnapPointsFromEdges(div);
    };

    function updateDivisions() {
      createSnapPointsFromEdges(currentDivision);
    }

    function createSnapPointsFromEdges(divisions) {
      snapPointsGroup.clear();
      if (!currentEdgesGeometry) return;
      const div = parseInt(divisions);
      const attr = currentEdgesGeometry.attributes.position;
      const array = attr.array;
      const points = [];

      const isSphere = (currentMesh && currentMesh.userData.type === 'sphere');
      const steps = isSphere ? Math.max(1, Math.floor(div / 2)) : div;

      for (let i = 0; i < attr.count; i += 2) {
        const v1 = new THREE.Vector3(array[i * 3], array[i * 3 + 1], array[i * 3 + 2]);
        const v2 = new THREE.Vector3(array[(i + 1) * 3], array[(i + 1) * 3 + 1], array[(i + 1) * 3 + 2]);
        for (let j = 0; j <= steps; j++) {
          const t = j / steps;
          points.push(new THREE.Vector3().lerpVectors(v1, v2, t));
        }
      }

      const uniquePoints = [];
      points.forEach(p => {
        const distThreshold = isSphere ? 0.05 : 0.01;
        if (!uniquePoints.some(up => up.distanceTo(p) < distThreshold)) uniquePoints.push(p);
      });

      const dotGeo = new THREE.SphereGeometry(0.18, 8, 8);
      const dotMat = new THREE.MeshBasicMaterial({ color: 0x555555, transparent: true, opacity: 0.4 });

      const MAX_POINTS = 3000;
      if (uniquePoints.length > MAX_POINTS) uniquePoints.length = MAX_POINTS;

      uniquePoints.forEach(p => {
        const dot = new THREE.Mesh(dotGeo, dotMat); dot.position.copy(p); snapPointsGroup.add(dot);
      });
    }

    function calculateIntersectionPointsAndCreateCap(plane, planeIndex) {
      if (!currentEdgesGeometry) return [];

      const array = currentEdgesGeometry.attributes.position.array;
      const count = currentEdgesGeometry.attributes.position.count;
      const newPoints = [];

      for (let i = 0; i < count; i += 2) {
        const v1 = new THREE.Vector3(array[i * 3], array[i * 3 + 1], array[i * 3 + 2]);
        const v2 = new THREE.Vector3(array[(i + 1) * 3], array[(i + 1) * 3 + 1], array[(i + 1) * 3 + 2]);
        const line = new THREE.Line3(v1, v2);
        const target = new THREE.Vector3();
        const intersection = plane.intersectLine(line, target);
        if (intersection) {
          if (!newPoints.some(p => p.distanceTo(intersection) < 0.0001)) newPoints.push(intersection.clone());
        }
      }

      intersectSnapGroup.clear();
      const intGeo = new THREE.SphereGeometry(0.15, 8, 8);
      const intMat = new THREE.MeshBasicMaterial({ color: 0x4CAF50 });
      newPoints.forEach(p => {
        const mesh = new THREE.Mesh(intGeo, intMat); mesh.position.copy(p); intersectSnapGroup.add(mesh);
      });

      if (newPoints.length >= 3) {
        createCapFromPoints(planeIndex, newPoints, plane);
      } else {
        if (capMeshes[planeIndex]) { scene.remove(capMeshes[planeIndex]); capMeshes[planeIndex] = null; }
      }
      return newPoints;
    }

    function createCapFromPoints(planeIndex, points3D, plane) {
      const centroid = new THREE.Vector3(0, 0, 0);
      points3D.forEach(p => centroid.add(p));
      centroid.divideScalar(points3D.length);

      const n = plane.normal.clone().normalize();
      let ref = new THREE.Vector3(0, 1, 0);
      if (Math.abs(n.dot(ref)) > 0.999) ref.set(1, 0, 0);
      const tangent = ref.clone().cross(n).normalize();
      const bitangent = n.clone().cross(tangent).normalize();

      const pts2 = points3D.map(p3 => {
        const rel = new THREE.Vector3().subVectors(p3, centroid);
        return new THREE.Vector2(rel.dot(tangent), rel.dot(bitangent));
      });
      const paired = pts2.map((p2, i) => ({ p2, angle: Math.atan2(p2.y, p2.x), orig3: points3D[i] }));
      paired.sort((a, b) => a.angle - b.angle);

      const shape = new THREE.Shape(paired.map(x => x.p2));
      const shapeGeo = new THREE.ShapeGeometry(shape);

      const basisMatrix = new THREE.Matrix4();
      basisMatrix.makeBasis(tangent, bitangent, n);
      shapeGeo.applyMatrix4(basisMatrix);
      shapeGeo.translate(centroid.x, centroid.y, centroid.z);

      const otherPlanes = planes.filter(p => p !== plane);
      const mat = new THREE.MeshPhongMaterial({
        color: SECTION_COLOR,
        side: THREE.DoubleSide,
        shininess: 10,
        clippingPlanes: otherPlanes,
        clipShadows: true
      });

      if (capMeshes[planeIndex]) { scene.remove(capMeshes[planeIndex]); capMeshes[planeIndex] = null; }

      const capMesh = new THREE.Mesh(shapeGeo, mat);
      capMesh.renderOrder = 2;
      capMeshes[planeIndex] = capMesh;
      scene.add(capMesh);
    }

    // ===== å…¥åŠ›ãƒ»æ“ä½œ =====
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    function addMarker(pos, index) {
      const geo = new THREE.SphereGeometry(0.3, 16, 16);
      const colors = [0xff5252, 0x2196F3, 0x9C27B0, 0xFF9800, 0x4CAF50, 0x00BCD4, 0xE91E63, 0x795548, 0x607D8B, 0xFFEB3B];
      const color = colors[index % colors.length];
      const mat = new THREE.MeshBasicMaterial({ color: color });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.copy(pos);
      scene.add(mesh);
      cutMarkers[index].push(mesh);
    }

    window.addEventListener('pointerdown', (event) => {
      if (event.target.closest('#top-nav')) return;

      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);

      const targets = [...snapPointsGroup.children, ...intersectSnapGroup.children];
      const intersects = raycaster.intersectObjects(targets);

      if (intersects.length > 0) {
        const p = intersects[0].object.position.clone();
        const currentList = cutPoints[currentCutIndex];
        if (currentList.length >= 3) return;
        if (currentList.some(exist => exist.distanceTo(p) < 0.1)) return;

        currentList.push(p);
        addMarker(p, currentCutIndex);
        updateStatusUI();

        if (currentList.length === 3) applyCut(currentCutIndex);
      }
    });

    function applyCut(index) {
      const pts = cutPoints[index];
      const plane = new THREE.Plane();
      plane.setFromCoplanarPoints(pts[0], pts[1], pts[2]);
      planes[index].copy(plane);

      calculateIntersectionPointsAndCreateCap(planes[index], index);

      // ä»–ã®åˆ‡æ–­é¢ã‚‚å†è¨ˆç®—
      for (let i = 0; i < numCuts; i++) {
        if (i !== index && cutPoints[i].length === 3) {
          calculateIntersectionPointsAndCreateCap(planes[i], i);
        }
      }

      updateStatusUI();
      updateCutTabStyles();
    }

    function updateStatusUI() {
      const count = cutPoints[currentCutIndex].length;
      const box = document.getElementById('status-box');
      box.innerText = `${count} / 3`;
      if (count === 3) box.classList.add('status-ok'); else box.classList.remove('status-ok');

      const flipBtn = document.getElementById('btn-flip');
      flipBtn.style.display = (cutPoints[currentCutIndex].length === 3) ? 'block' : 'none';
    }

    function updateCutTabStyles() {
      for (let i = 0; i < numCuts; i++) {
        const tab = document.getElementById('cut-tab-' + i);
        if (tab) {
          tab.classList.toggle('has-cut', cutPoints[i].length === 3);
        }
      }
    }

    window.switchCutTab = function (index) {
      currentCutIndex = index;
      for (let i = 0; i < numCuts; i++) {
        const tab = document.getElementById('cut-tab-' + i);
        if (tab) tab.classList.toggle('active', i === index);
      }
      updateStatusUI();
    };

    window.addNewCut = function () {
      if (numCuts >= MAX_CUTS) {
        alert('åˆ‡æ–­ã¯æœ€å¤§' + MAX_CUTS + 'å›ã¾ã§ã§ã™');
        return;
      }
      numCuts++;
      planes.push(new THREE.Plane(new THREE.Vector3(0, -1, 0), 1000));
      cutPoints.push([]);
      cutMarkers.push([]);
      capMeshes.push(null);

      // ã‚¿ãƒ–ã‚’è¿½åŠ 
      const container = document.getElementById('cut-tabs-container');
      const newTab = document.createElement('button');
      newTab.className = 'cut-tab';
      newTab.id = 'cut-tab-' + (numCuts - 1);
      newTab.textContent = 'åˆ‡æ–­' + toCircledNumber(numCuts);
      newTab.onclick = () => switchCutTab(numCuts - 1);
      container.appendChild(newTab);

      // æ–°ã—ã„ã‚¿ãƒ–ã«åˆ‡ã‚Šæ›¿ãˆ
      switchCutTab(numCuts - 1);

      // ãƒãƒ†ãƒªã‚¢ãƒ«ã®æ›´æ–°
      matSolid.clippingPlanes = planes;
    };

    function toCircledNumber(n) {
      const circled = ['â‘ ', 'â‘¡', 'â‘¢', 'â‘£', 'â‘¤', 'â‘¥', 'â‘¦', 'â‘§', 'â‘¨', 'â‘©'];
      return circled[n - 1] || n.toString();
    }

    window.flipCurrentCut = function () {
      if (cutPoints[currentCutIndex].length !== 3) return;
      planes[currentCutIndex].normal.negate();
      planes[currentCutIndex].constant *= -1;
      calculateIntersectionPointsAndCreateCap(planes[currentCutIndex], currentCutIndex);

      for (let i = 0; i < numCuts; i++) {
        if (i !== currentCutIndex && cutPoints[i].length === 3) {
          calculateIntersectionPointsAndCreateCap(planes[i], i);
        }
      }
    };

    window.resetCurrentCut = function () {
      resetCut(currentCutIndex);
    };

    function resetCut(index) {
      cutPoints[index] = [];
      cutMarkers[index].forEach(m => scene.remove(m));
      cutMarkers[index] = [];
      planes[index].setComponents(0, -1, 0, 1000);
      if (capMeshes[index]) { scene.remove(capMeshes[index]); capMeshes[index] = null; }

      for (let i = 0; i < numCuts; i++) {
        if (i !== index && cutPoints[i].length === 3) {
          calculateIntersectionPointsAndCreateCap(planes[i], i);
        }
      }
      updateStatusUI();
      updateCutTabStyles();
    }

    window.resetAll = function () {
      for (let i = 0; i < numCuts; i++) {
        cutPoints[i] = [];
        cutMarkers[i].forEach(m => scene.remove(m));
        cutMarkers[i] = [];
        planes[i].setComponents(0, -1, 0, 1000);
        if (capMeshes[i]) { scene.remove(capMeshes[i]); capMeshes[i] = null; }
      }
      intersectSnapGroup.clear();
      updateDivisions();
      switchCutTab(0);
      updateCutTabStyles();
    };

    // åˆæœŸåŒ–
    setShapeUI('cube');

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>

</body>

</html>